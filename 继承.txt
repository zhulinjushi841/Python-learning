继承
目标
单继承
多继承
面向对象的三大特性
1.封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中
2.继承 实现代码的复用，相同的代码不需要重复的编写
3.多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的复杂度
01.单继承
1.1继承的概念、语法和特点
继承的概念：子类 拥有 父类 的所有 方法 和 属性

1.1继承的概念、语法和特点
继承的概念：子类 拥有 父类 的所有 方法 和 属性
1）继承的语法
class 类名(父类名):
	pass
子类 继承自 父类，可以直接 享受 父类中已经封装好了的方法，不需要在此开发
子类 中应当根据 职责，封装 子类特有的属性和方法
2）专业术语
Dog类是Animal类的子类，Animal类是Dog类的父类，Dog类从Animal类继承
Dog类是Animal类的派生类，Animal类是Dog类的基类，Dog类从Animal类派生
3）继承的传递性
C类从B类继承，B类又从A类继承
那么C类就具有B类和A类的所有属性和方法
子类 拥有 父类 以及 父类的父类 中封装的所有属性 和 方法


1.2方法的重写
子类拥有 父类的所有 方法 和 属性
子类继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发
应用场景
当父类的方法实现不能喝满足子类的需求的时候，可以对方法进行 重写(override)
重写 父类方法有两种情况：
1.覆盖 父类的方法
2.对父类方法进行 扩展

1)覆盖父类的方法
如果在开发中，父类的方法实现 和 子类的方法实现，完全不同
就可以使用 覆盖 的方式，在子类中 重新填写 父类的方法实现
具体的实现方式，就相当于在 子类中 定义了一个与父类同名的方法并实现
重写之后，在运行实，只会调用子类中重写的方法，而不会再调用 父类封装的方法

如果子类中，重写了父类的方法，在使用子类对象调用方法的时候，就会调用子类中重写的方法

2）对父类方法进行 扩展
如果在开发中，子类的方法实现 中 包含 父类的方法实现 
父类原本封装的方法实现 是 子类方法的一部分 也即在原有的功能的基础上增加一些新的功能
就可以使用 扩展 的方式
1.在子类中 重写 父类的方法
2.在需要的位置使用  super().父类方法  来调用父类方法的执行
3.代码其他的位置针对子类的需求，编写子类特有的代码实现

关于super
在Python中 super是一个特殊的类
super()就是使用super类创建出来的对象
最常用的场景就是在 重写父类方法时，调用 在父类中封装的方法实现
如果在子类中需要调用原本在父类中封装的方法，就需要使用super()
例如： super().bark()

1.3父类的 私有属性 和 私有方法
1.子类对象 不能 在自己的方法内部，直接 访问 父类的 私有属性 或者 私有方法
2.子类方法 可以通过 父类 的共有方法 间接 访问到 私有属性 或者 私有方法
私有属性、方法 是对象的隐私，不对外公开，外界 以及 子类都不能够直接访问
私有属性、方法 通常用语做一些内部的事情



02.多继承
概念
子类 可以拥有 多个父类，并且具有 所有父类 的属性 和 方法
例如：孩子 会继承自己 父亲 和 母亲 的特性
语法 
class 子类名(父类名1，父类名2...)
	pass
2.1多继承的使用注意事项
在开发时，应该尽量避免不同的父类中存在同名的方法这种容易产生混淆的情况，如果父类之间
存在同名的属性或者方法，应该尽量避免使用多继承

Python中的MRO——方法搜索顺序(了解)
方法搜索顺序就是一个对象在调用某一个方法时，Python的解释器是按照什么样的顺序在创建这个类，
以及父类之间搜索方法。
Python中针对 类 提供了一个内置属性__mro__可以查看 方法 搜索顺序
MRO是method resolution order,主要用于在 多继承时判断方法，属性 的调用 路径

确定C类对象调用方法的顺序
print(C.__mro__)

2.2新式类与旧式(经典)类
object是Python为所有对象提供的 基类，提供有一些内置的属性和方法，可以使用dir函数查看
新式类：以object为基类的类，推荐使用
经典类：不以object为基类的类，不推荐使用
在Python3.x中定义类的时候，如果没有指定父类，就会默认使用 object 作为该类的基类——Python3.x
中定义的类都是 新式类
在Python2.x中定义类时，如果没有指定父类，则不会以object作为基类
新式类 和 经典类 在多继承时，会影响到方法的搜索顺序

为了保证编写的代码能够同时在Python2.x 和 Python3.x运行，今后在定义类时，如果没有父类，
建议统一继承自object
class  类名(object):
	pass

如上图所示的这种类定义方式，就是新式类，可以使用object提供的内置属性和方法





